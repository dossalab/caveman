import re
import sys
from PIL import Image
from argparse import ArgumentParser
from os.path import join as pathjoin
from dataclasses import dataclass
from typing import Any
from textwrap import dedent

VIDEO_BIT_PORT = 'PORTD'
VIDEO_BIT_PIN = 7

@dataclass
class SpriteProto:
    identifier: str
    width: int
    height: int
    pixels: Any

def path_to_identifier(path: str):
     return re.sub(r"[\/\.,-]", "_", path)

def is_even(n):
    return n % 2 == 0

class Formatter:
    def __init__(self, file, compress=False):
        self.file = file
        self.compress = compress

    def out(self, a: str, correct_indent=True):
        print(dedent(a) if correct_indent else a, file=self.file)

    def add_header_entry(self, sprite: SpriteProto, identifiers: []):
        for identifier in identifiers:
            self.out(f'extern void {identifier}(void);', correct_indent=False)
        
        self.out(f'\nvoid (*{sprite.identifier}_line_table[])(void) = {{')

        for identifier in identifiers:
            self.out(f'    {identifier},', correct_indent=False)

        self.out(f'''
            }};

            const struct sprite_proto {sprite.identifier}_proto = {{
                .width = {sprite.width},
                .height = {sprite.height},
                .line_table = {sprite.identifier}_line_table
            }};
            ''')

    def _compress_line(self, line: [], min_following):
        current = line[0]
        following = 0

        for x in range(1, len(line)):
            if line[x] == current:
                following += 1
            else:
                if following >= min_following:
                    yield (current, following)
                else:
                    # Emit the value itself + following occurences
                    for _ in range(following + 1):
                        yield (current, 0)

                current = line[x]
                following = 0

        # we don't care about the reminder as it's the end of scanline. Just yield the last value
        if following > 0:
            yield (current, 0)

    def _no_compress_line(self, line: [], min_run_length=0):
        for x in range(len(line)):
            yield((line[x], 0))

    def _line_compressor(self, line: [], min_run_length):
        if self.compress:
            yield from self._compress_line(line, min_run_length)
        else:
            yield from self._no_compress_line(line, min_run_length)

    # ldi = 1 cycle
    # rcall = 3 cycles
    # ret = 4 cycles
    #
    # loop itself:
    # dec = 1
    # brne (n - 1 iterations) = 2
    # brne (last iteration) = 1
    #
    # so, total cycles: 8 + ((n - 1) * 3) + 2 = 8 + 3n - 3 + 2 = 3n + 7
    # minimum loops: 3 * 1 + 7 = 10

    def _calculate_delay_counter_value(self, x) -> (int, int):
        val = x - 7
        rem = val % 3
        return (val // 3, rem)

    def add_source_entry(self, sprite: SpriteProto) -> []:
        min_delay_loops = 10
        collected_identifiers = []

        for y in range(sprite.height):
            line = [sprite.pixels[x, y] for x in range(sprite.width)]
            line_identifier = f'{sprite.identifier}_data_{y}'

            self.out(f'''\
                ; line {y}
                .global {line_identifier}
                {line_identifier}:''')

            collected_identifiers.append(line_identifier)

            for value, following in self._line_compressor(line, min_delay_loops // 2): # each cbi / sbi takes 2 cycles
                command = 'sbi' if value > 127 else 'cbi'
                self.out(f'    {command} _SFR_IO_ADDR({VIDEO_BIT_PORT}), {VIDEO_BIT_PIN}', correct_indent=False)

                if following > 0:
                    num_cycles_to_burn = following * 2 # each cbi / sbi takes 2 cycles
                    num_delay_loops, rem = self._calculate_delay_counter_value(num_cycles_to_burn)

                    self.out(f'; {following} of the same entries follow')
                    self.out(f'    ldi r18, {num_delay_loops}\n    rcall delay_loop', correct_indent=False)

                    for _ in range(rem):
                        self.out('    nop', correct_indent=False)

            self.out('    ret\n', correct_indent=False)

        return collected_identifiers

    def write_source_preamble(self):
        self.out('''\
            ; Autogenerated file - DO NOT EDIT

            #include <avr/io.h>

            .text

            ; Input: r18 = N (delay loops)
            delay_loop:
                dec r18
                brne delay_loop
                ret
            ''')

    def write_header_preamble(self):
        self.out('''\
            // Autogenerated file - DO NOT EDIT

            #pragma once

            #include "video.h"
            ''')

def parse_args():
    p = ArgumentParser()

    p.add_argument('--basedir', type=str, required=True)
    p.add_argument('--input', type=str, required=True, action='append')
    p.add_argument('--compress', action='store_true')
    p.add_argument('output')

    return p.parse_args()

def main():
    args = parse_args()

    with open(f'{args.output}.S', 'w') as source_file, open(f'{args.output}.h', 'w') as header_file:
        source = Formatter(source_file, args.compress)
        header = Formatter(header_file)

        source.write_source_preamble()
        header.write_header_preamble()

        total_sprites = 0

        for path in args.input:
            image = Image.open(pathjoin(args.basedir, path)).convert("L")
            width, height = image.size

            if not is_even(width + 1): # 1 is a padding for ret instruction
                print(f'{path}: width must be odd, detected width is {width}', file=sys.stderr)
                continue

            sprite = SpriteProto(
                identifier=path_to_identifier(path),
                width=width,
                height=height,
                pixels=image.load()
            )

            identifiers = source.add_source_entry(sprite)
            header.add_header_entry(sprite, identifiers)

            total_sprites += 1

        print(f'{total_sprites} sprites added')

if __name__ == '__main__':
    main()
