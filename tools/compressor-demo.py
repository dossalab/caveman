from argparse import ArgumentParser
from os.path import join as pathjoin
import re
import sys
from dataclasses import dataclass
from compressor import compress, Match, Repeat, decompress
import logging

from PIL import Image

section_separator = '------------------------------------------------------'

VIDEO_BIT_PORT = 'PORTD'
VIDEO_BIT_PIN = 7

@dataclass
class SpriteProto:
    identifier: str
    width: int
    height: int
    index: list[int]

    def c_struct(self) -> str:
        return f'''\
struct sprite_proto {self.identifier}_proto = {{
    .width = {self.width},
    .height = {self.height},
    .line_table = {self.identifier}_line_table
}};'''

def path_to_identifier(path: str) -> str:
     return re.sub(r"[\/\.,-]", "_", path)

# call takes 3 cycles, ret takes 4 cycles + 1 nop padding = 8 cycles (4 ops)
# call is 2 bytes, ret is 2 bytes = 4 bytes (2 ops)
# so that saves us 4 bytes
delay_fixed_min_ops = 4
delay_fixed_1_function = '''\
delay_fixed_1:
    nop
    ret'''

delay_loop_min_ops = 5
delay_loop_function = '''\
; Input: r18 = N (delay loops)
delay_loop:
    dec r18
    brne delay_loop
    ret'''

# ldi = 1 cycle
# rcall = 3 cycles
# ret = 4 cycles
#
# loop itself:
# dec = 1
# brne (n - 1 iterations) = 2
# brne (last iteration) = 1
#
# so, total cycles: 8 + ((n - 1) * 3) + 2 = 8 + 3n - 3 + 2 = 3n + 7
# minimum cycles: 3 * 1 + 7 = 10 (5 ops)

def calculate_delay_counter_value(x) -> tuple[int, int]:
    val = x - 7
    rem = val % 3
    return (val // 3, rem)

def make_line_identifier(line: int) -> str:
    return f'line_table_data_{line}'

def make_dictionary_identifier(line: int) -> str:
    return f'sprites_dictionary_line_{line}'

def create_assembly_dump(lines: dict[tuple, int], dictionary, file=sys.stderr) -> None:
    out = lambda str: print(str, file=file)

    def out_preamble() -> None:
        out('; Autogenerated file - DO NOT EDIT\n\n#include <avr/io.h>\n\n.text')

    def out_simple_instruction(value: int) -> None:
        command = 'sbi' if value > 127 else 'cbi'
        out(f'    {command} _SFR_IO_ADDR({VIDEO_BIT_PORT}), {VIDEO_BIT_PIN}')

    def out_delay_call(repetitions: int) -> None:
        cycles_per_op = 2

        if repetitions < delay_loop_min_ops:
            out(f'    rcall delay_fixed_1')
        else:
            r18, nops = calculate_delay_counter_value(repetitions * cycles_per_op)
            out(f'    ldi r18, {r18}\n    rcall delay_loop')
            for _ in range(nops):
                out('    nop')

    def out_line_function(identifier: str, line: tuple[int], optimize_line_start_level = False) -> None:
        out(f'.global {identifier}\n{identifier}:')
        neutral_level = 0

        for x in range(len(line)):
            value = line[x]

            if isinstance(value, int):
                out_simple_instruction(value)
            elif isinstance(value, Match):
                call_identifier = make_dictionary_identifier(value.id)
                out('    ; match')
                out(f'    nop\n    rcall {call_identifier}')
            elif isinstance(value, Repeat):
                repetitions = value.repetitions

                # if repetition starts with the same level as we're currently at (beginning of line),
                # no need to set it, just add one extra repetition instead of level setting

                if optimize_line_start_level and x == 0:
                    if value.value == neutral_level:
                        repetitions += 1
                    else:
                        out_simple_instruction(value.value)
                else:
                    out_simple_instruction(value.value)

                out(f'    ; {repetitions} repetition(s)')
                out_delay_call(repetitions)

        out('    ret\n')

    out_preamble()

    out(delay_fixed_1_function + '\n')
    out(delay_loop_function + '\n')

    for line, y in lines.items():
        identifier = make_line_identifier(y)
        out_line_function(identifier, line, optimize_line_start_level=True)

    out('; dictionary')
    for match, sequence in dictionary.items():
        identifier = make_dictionary_identifier(match.id)
        out_line_function(identifier, sequence)

def create_header_file(lines: dict[tuple, int], sprites: list[SpriteProto], file=sys.stderr) -> None:
    out = lambda str: print(str, file=file)

    out('// Autogenerated file - DO NOT EDIT\n\n#include <avr/pgmspace.h>\n#include "video.h"\n')

    for _, y in lines.items():
        identifier = make_line_identifier(y)
        out(f'extern void {identifier}(void);')

    for sprite in sprites:
        out(f'\nconst video_line_func_t {sprite.identifier}_line_table[] PROGMEM = {{')

        for y in sprite.index:
            identifier = make_line_identifier(y)
            out(f'    {identifier},')

        out('};\n\n' + sprite.c_struct())

def parse_args():
    p = ArgumentParser()

    p.add_argument('--basedir', type=str, required=True)
    p.add_argument('--input', type=str, required=True, action='append')
    p.add_argument('--compress', action='store_true')
    p.add_argument('--debug', action='store_true')
    p.add_argument('--force', action='store_true', help='skip decompression check')
    p.add_argument('output')

    return p.parse_args()

def image_size(image: list[tuple[int]]) -> int:
    return sum(len(line) for line in image)

def main(args) -> None:
    sprites = []

    input_line_dict: dict[tuple, int] = {}
    line_id = 0

    for path in args.input:
        image = Image.open(pathjoin(args.basedir, path)).convert("L")
        width, height = image.size

        pixels = image.load()
        if pixels is None:
            raise RuntimeError("image.load() failed")

        line_table_index: list[int] = []

        for y in range(height):
            line=tuple(pixels[x, y] for x in range(width))

            if not line in input_line_dict:
                input_line_dict[line] = line_id
                line_table_index.append(line_id)
                line_id += 1
            else:
                line_table_index.append(input_line_dict[line])

        sprite = SpriteProto(
            identifier=path_to_identifier(path),
            width=width,
            height=height,
            index=line_table_index
        )

        sprites.append(sprite)            

    input_lines: list[tuple] = list(input_line_dict.keys())
    output_lines, dictionary = compress(input_lines, 2, 1 + delay_fixed_min_ops, preserve_trailing=False)

    # Funky...
    output_line_dict: dict[tuple, int] = {}
    for output_line, (input_line, y) in zip(output_lines, input_line_dict.items()):
        output_line_dict[output_line] = y

    logger.debug(section_separator)
    logger.debug('compressor input:')

    for line in input_lines:
        logger.debug(line)

    logger.debug(section_separator)
    logger.debug('compressor output:')

    for line in output_lines:
        logger.debug(line)

    for name, seq in dictionary.items():
        logger.debug(f'{name} -> {seq}')

    if not args.force:
        decompressed = list(decompress(output_lines, dictionary))

        if decompressed != input_lines:
            logger.error('------------------------------------------------------')
            logger.error('> compressed / decompressed mismatch!')

            for y, (o, d) in enumerate(zip(input_lines, decompressed)):
                if o != d:
                    logger.info(f'mismatch at line {y}:')
                    logger.info(f'-: {o}')
                    logger.info(f'+: {d}')

            raise RuntimeError("compression failed")

    input_size = image_size(input_lines)
    compressed_size = image_size(output_lines) + image_size(list(dictionary.values()))

    logger.info(f'{input_size} original size, {input_size * 2} bytes')
    logger.info(f'{compressed_size} compressed size, {compressed_size * 2} bytes')

    with open(f'{args.output}.S', 'w') as file:
        create_assembly_dump(output_line_dict, dictionary, file=file)

    with open(f'{args.output}.h', 'w') as file:
        create_header_file(output_line_dict, sprites, file=file)

if __name__ == '__main__':
    args = parse_args()

    if args.debug:
        loglevel=logging.DEBUG
    else:
        loglevel=logging.INFO

    logging.basicConfig(level=loglevel, format='(%(levelname).1s) %(message)s')
    logger = logging.getLogger(__name__)

    main(args)
