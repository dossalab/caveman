import re
import sys
from PIL import Image
from argparse import ArgumentParser
from os.path import join as pathjoin
from dataclasses import dataclass
from typing import Any
from textwrap import dedent

VIDEO_BIT_PORT = 'PORTD'
VIDEO_BIT_PIN = 7

@dataclass
class SpriteProto:
    identifier: str
    width: int
    height: int
    pixels: Any

def path_to_identifier(path: str):
     return re.sub(r"[\/\.,-]", "_", path)

def is_even(n):
    return n % 2 == 0

class Formatter:
    def __init__(self, file):
        self.file = file

    def out(self, a: str, correct_indent=True):
        print(dedent(a) if correct_indent else a, file=self.file)

    def add_header_entry(self, sprite: SpriteProto, identifiers: []):
        for identifier in identifiers:
            self.out(f'extern void {identifier}(void);', correct_indent=False)
        
        self.out(f'\nvoid (*{sprite.identifier}_line_table[])(void) = {{')

        for identifier in identifiers:
            self.out(f'    {identifier},', correct_indent=False)

        self.out(f'''
            }};

            const struct sprite_proto {sprite.identifier}_proto = {{
                .width = {sprite.width},
                .height = {sprite.height},
                .line_table = {sprite.identifier}_line_table
            }};
            ''')

    def _compress_line(self, line: [], min_run_length):
        current = line[0]
        following = 0

        for x in range(1, len(line)):
            if line[x] == current:
                following += 1
            else:
                if following >= min_run_length:
                    yield (current, following)
                else:
                    for _ in range(following):
                        yield (current, 0)

                current = line[x]
                following = 0

        # we don't care about the reminder as it's the end of scanline. Just yield the last value
        if following > 0:
            yield (current, 0)

    def add_source_entry(self, sprite: SpriteProto) -> []:
        # 3 instructions inside delay loop and then 10 cycles for function call & return
        def calculate_delay_counter_value(x) -> (int, int):
            val = x - 10
            rem = val % 3

            return (val // 3, rem)

        min_following_loops = 10
        offset = 0
        collected_identifiers = []

        for y in range(sprite.height):
            line = [sprite.pixels[x, y] for x in range(sprite.width)]
            instructions = 0
            line_identifier = f'{sprite.identifier}_data_{y}'

            self.out(f'''\
                ; line {y}, offset {offset}
                .global {line_identifier}
                {line_identifier}:''')

            collected_identifiers.append(line_identifier)

            for pair in self._compress_line(line, min_following_loops):
                value = pair[0]
                following = pair[1]

                command = 'sbi' if value > 127 else 'cbi'
                self.out(f'    {command} _SFR_IO_ADDR({VIDEO_BIT_PORT}), {VIDEO_BIT_PIN}', correct_indent=False)
                instructions += 1

                if following > 0:
                    # n_delay_loops, rem = calculate_delay_counter_value(following)
                    # self.out(f'; {following} of the same entries follow')
                    # self.out(f'    ldi r18, {n_delay_loops}\n    rcall delay_loop', correct_indent=False)
                    # instructions += 2
                    rem = following

                    for _ in range(rem):
                        self.out('    nop', correct_indent=False)
                        instructions += 1

            # +1 is for ret, remember? Pad the number of instructions to make them even
            if not is_even(instructions + 1):
                self.out('    nop', correct_indent=False)
                instructions += 1

            self.out('    ret\n', correct_indent=False)
            instructions += 1

            offset += instructions

        return collected_identifiers

    def write_source_preamble(self):
        self.out('''\
            ; Autogenerated file - DO NOT EDIT

            #include <avr/io.h>

            .text

            ; Input: r18 = N (delay loops)
            delay_loop:
                dec r18
                brne delay_loop
                ret
            ''')

    def write_header_preamble(self):
        self.out('''\
            // Autogenerated file - DO NOT EDIT

            #pragma once

            #include "video.h"
            ''')

def parse_args():
    p = ArgumentParser()

    p.add_argument('--basedir', type=str, required=True)
    p.add_argument('--input', type=str, required=True, action='append')

    return p.parse_args()

def main():
    args = parse_args()

    with open('generated-sprites.S', 'w') as source_file, open('generated-sprites.h', 'w') as header_file:
        source = Formatter(source_file)
        header = Formatter(header_file)

        source.write_source_preamble()
        header.write_header_preamble()

        total_sprites = 0

        for path in args.input:
            image = Image.open(pathjoin(args.basedir, path)).convert("L")
            width, height = image.size

            if not is_even(width + 1): # 1 is a padding for ret instruction
                print(f'{path}: width must be odd, detected width is {width}', file=sys.stderr)
                continue

            sprite = SpriteProto(
                identifier=path_to_identifier(path),
                width=width,
                height=height,
                pixels=image.load()
            )

            identifiers = source.add_source_entry(sprite)
            header.add_header_entry(sprite, identifiers)

            total_sprites += 1

        print(f'{total_sprites} sprites added')

if __name__ == '__main__':
    main()
